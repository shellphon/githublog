---
layout: post
title:  图片局部放大的实现
category: Hello Code
keywords: vuejs2, vue-cli
description: 
---

上次在sf看到一个问题，用vue实现类似淘宝商品图片局部放大的效果，想想自己还没实现过，就尝试了一下，在搜索结果下，看到张鑫旭的一篇[博文讲解](http://www.zhangxinxu.com/wordpress/2010/08/apple-iphone4%E5%AE%98%E7%BD%91%E5%9B%BE%E7%89%87%E8%A7%86%E7%BD%91%E8%86%9C%E6%94%BE%E5%A4%A7%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/),大致明白了其原理，于是写个对应的组件尝试一下。

### 需求

先描述一下大致需求：有几张小图，横向排列，当选中其中一张时，会显示小图对应的大图，并且在鼠标移动到大图的局部位置时，悬浮显示其局部位置的放大效果。

此需求分为两点：

1. 小图排列，选中时显示对应的大图 （这里大小图应该有固定的显示尺寸了）
2. 鼠标移动到大图时，显示局部位置放大效果（本文主题）

### 实现描述

对于需求一，在vue数据状态驱动机制下，其实就是定义两个数据：`imgs`（图片数据数组，含大图小图地址等细节）、`activeIndex`（当前选中索引）

只要控制好当小图点击时响应函数修改`activeIndex`即可，根据数据驱动，view也会跟着变化。

对于需求二，从上面提到的文章已经知道怎么实现了，主要逻辑是，鼠标移动时计算鼠标在图片里的相对位置，其次则是悬浮元素设置`background-image`，通过鼠标的相对位置来设置`background-position`.

当如果悬浮元素取得图片跟大图图片尺寸一致的话，其实就并没有什么放大效果了，纯粹局部裁剪的效果。

所以在描述需求时提到了一点，大小图应该有固定的显示尺寸，大图显示的尺寸一般并不会是原图尺寸而是一个固定比原图尺寸小的图，而放大效果，恰恰就是用的原图尺寸，这样就有了所谓的放大效果。

### 关于计算

逻辑弄清楚了，写代码前，需要确定一些计算公式，比如鼠标相对图片的相对位置、获取局部的背景图定位

#### 鼠标的相对位置

这块很好做，鼠标的移动事件对象event带有pageX和pageY两个值，分别对应x、y轴上相对文档的坐标。

而要相对图片，则还需要图片的相对文档坐标信息，这个可以用`getBoundingClientRect()`获得`top`和`left`.

这样相对位置 就是 `x = pageX - left; y = pageY - top;`

#### 局部背景图定位

显示局部的浮层有一定的宽高，假设为`detailWidth` \ `detailHeight`，我们获取的鼠标相对位置坐标实际上是相对于固定尺寸的图片的坐标，如果在实际原图大小上，其对应的坐标需要一定比例的转换，假如原图是显示图的两倍，那么相对位置a\b，在原图的位置应该是 2a\2b,这样我们就可以通过`background-position: -2apx -2bpx`来定位了。

但是如果这样子的话，局部显示的位置还有点问题，那就是我们想要的是鼠标指向的点应该显示在局部浮层的中心，所以定位还要考虑浮层本身的宽高尺寸。

因此定位公式如下：

> x = - (posX × 比例 - detailWidth/2)  
  y = - (posY × 比例 - detailHeight/2)

### 代码

组件代码如下：

{% highlight html %}
<template>
  <div class="img-show">
    <div class="big-img"><img @mousemove="move" @mouseout='detailShow=false' 
    :src="imgs[activeIndex].bigsrc" 
    :title="imgs[activeIndex].title">
        <div class="detail" :style="{width: detailWidth+'px',
         height: detailHeight+'px',
         backgroundImage:'url('+imgs[activeIndex].bigsrc+')',
         backgroundRepeat: 'no-repeat', 
         top: detailTop+'px', 
         left: detailLeft+'px',
         backgroundPosition: detailPosition}" v-show="detailShow">
         </div>
    </div>
    <ul class="small-img">
      <li v-for='(img, index) in imgs' @click="showBig(index)" :class='{ active: activeIndex==index}'>
      <img :src="img.src" :title="img.title" alt="">
      </li>
    </ul>
    <button @click="messSort">乱排</button>
    <button @click="reverseSort">倒排</button>
  </div>
</template>

<script>
export default {
  name: 'imgshow',
  data () {
    var imgs = [
        {
          src:'http://localhost:10087/1.jpg',
          bigsrc:'http://localhost:10087/b1.jpg',
          title:'我是图1'
        },
        {
          src:'http://localhost:10087/2.jpg',
          bigsrc:'http://localhost:10087/b2.jpg',
          title:'我是图2'
        },
        {
          src:'http://localhost:10087/3.jpg',
          bigsrc:'http://localhost:10087/b3.jpg',
          title:'我是图3'
        },
        {
          src:'http://localhost:10087/4.jpg',
          bigsrc:'http://localhost:10087/b4.jpg',
          title:'我是图4'
        }
      ];
    return {
      imgs,
      activeIndex:0,
      detailShow:false,
      detailTop:0,
      detailLeft:0,
      detailWidth: 200,
      detailHeight: 200,
      detailPosition: '0 0'
    }
  },
  computed:{
    offset(){
      return this.$el.getBoundingClientRect()
    }
  },
  methods:{
    showBig (index){
      this.activeIndex = index
    },
    messSort (){
      this.imgs = this.imgs.sort((a,b)=>Math.random()>0.5)
    },
    reverseSort(){
      this.imgs = this.imgs.reverse()
    },
    move(e){
      this.detailShow = true
      var x = e.pageX - this.offset.left,
          y = e.pageY - this.offset.top;
          
          if(x>this.offset.width||x<0||y<0||y>this.offset.height){
            this.detailShow = false
            return;
          }
          this.detailTop = y-this.detailHeight
          this.detailLeft = x+this.detailWidth/2

          this.detailPosition = '-'+Math.round(x*(430/300)-this.detailWidth/2)+'px -'+Math.round(y*(430/300)-this.detailHeight/2)+'px'
    }
  }
}
</script>
<style scoped>
.img-show{
  width: 300px;
  margin:50px auto;
}
.big-img{
  width: 100%;
  position: relative;
}
.detail{
  position: absolute;
  border: 3px solid #fff;
}
.big-img img{
  width: 100%;
}
.small-img{
  width: 100%;
}
.small-img li{
  float: left;
  box-sizing: border-box;
  border:1px solid #fff;
  width: 25%;
  height: 25%;
  list-style: none;
  cursor: pointer;
}
.small-img li.active{
  border-color:#333;
}
.small-img img{
  width: 100%;
}
</style>

{% endhighlight %}

效果如下：

![image](http://dont27.qiniudn.com/img-show.gif)


对于边缘处的处理以及浮层为圆形的处理，暂不涉及了。局部放大的主要实现，其实也不难。