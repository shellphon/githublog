---
layout: post
title: fis项目mod.js浅析
category: Hello Code
---

一年多都在用`fis`，第一次看fis项目里模块化的具体实现方式

在看`mod.js`之前,我是先了解一下到底啥是`AMD`、`CMD`的。有助于帮助自己理解。

基本我都注释在代码里，还是先说一下`fis`项目里的`js`是怎么用的吧。

首先，一个页面级别的业务js，都是以这样的格式去写的.
{%highlight javascript%}
var business = {
  init:function(){
    //hello world
  }
};

module.exports = business;
{%endhighlight%}

为什么这么写呢，因为`fis`编译之后会自动给这份`js`包装一下变成这样。

{%highlight javascript%}
define("common:widget/xxx.js",function(require, exports, module){
  var business = {
    init:function(){
      //hello world
    }
  };
  module.exports = business;
});
{%endhighlight%}

然后呢，我们在其他地方要用这个js的时候就是这样调用的:

{%highlight javascript%}
var xxx = require("common:widget/xxx.js");//约定好了js模块的id
xxx.init();
{%endhighlight%}

然后项目就愉快的运行起来了，而实际上靠的就是`mod.js`的实现模块化

{%highlight javascript%}
/**
 * file: mod.js
 * ver: 1.0.6
 * update: 2014/1/15
 *
 * https://github.com/zjcqoo/mod
 */
 //全局变量
var require, define;

(function(global) {
    var head = document.getElementsByTagName('head')[0],
        //存储异步加载脚本时存储的异步加载完的回调函数
        loadingMap = {},
        //存储模块js，存储的是整一个模块被包裹的函数执行体
        factoryMap = {},
        //缓存已经require过的模块对象，可直接使用
        modulesMap = {},
        //标识已经引入的脚本
        scriptsMap = {},
        //js的资源对象
        resMap = {},
        //js的合并模块的资源对象
        pkgMap = {};


    //创建脚本：如果脚本在scriptsMap存在，则忽略，否则往head插入脚本    
    function createScript(url, onerror) {
        if (url in scriptsMap) return;
        //标识该脚本已在做引入处理
        scriptsMap[url] = true;

        var script = document.createElement('script');
        //创建失败回调
        if (onerror) {
            var tid = setTimeout(onerror, require.timeout);

            script.onerror = function() {
                clearTimeout(tid);
                onerror();
            };

            script.onreadystatechange = function() {
                if (this.readyState == 'complete') {
                    clearTimeout(tid);
                }
            }
        }
        script.type = 'text/javascript';
        script.src = url;
        head.appendChild(script);
        return script;
    }

    function loadScript(id, callback, onerror) {
        var queue = loadingMap[id] || (loadingMap[id] = []);
        queue.push(callback);

        //
        // resource map query
        //这里的初始化有点问题， 另外resMap应该是一个存储map.json数据的变量
        var res = resMap[id] || {};
        var pkg = res.pkg;
        var url;

        //异步加载模块的时候页面会生成一个传入res（map.json数据）的resourcMap函数执行
        if (pkg) {//如果模块有合并的版本，加载合并模块脚本
            url = pkgMap[pkg].url;
        } else {
            //呃，如果res为{},那url就是一个id？
            url = res.url || id;
        }

        createScript(url, onerror && function() {
            onerror(id);
        });
    }
    //项目代码里对js文件的模块封装
    define = function(id, factory) {
        //将模块代码存进factoryMap
        factoryMap[id] = factory;

        //loadScript时加载脚本后，脚本define函数触发，这里将loadScript时的回调！！！
        var queue = loadingMap[id];
        if (queue) {
            for(var i = 0, n = queue.length; i < n; i++) {
                queue[i]();
            }
            delete loadingMap[id];
        }
    };

    //同步require
    //调用模块js的方法：
    require = function(id) {
        //获得对应规则化的id，这里没规则 = =||
        id = require.alias(id);

        //从modulesMap里查找，如果有直接放回模块导出对象
        var mod = modulesMap[id];
        if (mod) {
            return mod.exports;
        }

        //
        // init module
        // 从factoryMap里获取：factoryMap是 define方法对模块js进行了存储
        var factory = factoryMap[id];
        if (!factory) {//连factoryMap都找不到，你没引入对应的js咯
            throw '[ModJS] Cannot find module `' + id + '`';
        }

        //modulesMap也对这个id进行了保存初始化
        mod = modulesMap[id] = {
            exports: {}
        };

        //
        // factory: function OR value
        //
        var ret = (typeof factory == 'function')
        //这就apply这后面两个参数，对mod进行了赋值处理（原来的mod是初始化的空对象）
                ? factory.apply(mod, [require, mod.exports, mod])
                : factory;

        if (ret) {
        //我去，如果factory，即模块js里面最后return了个变量之类的，分分钟把mod.exports给覆盖掉啊
        //所以，我相信，这里不过是ret初始化的时候因为factory是一个值才做的处理吧，但是从业务项目来看，这里factory本身注定是一个function了
            mod.exports = ret;
        }
        return mod.exports;
    };

    //
    require.async = function(names, onload, onerror) {
        if (typeof names == 'string') {
            names = [names];
        }

        for(var i = 0, n = names.length; i < n; i++) {
            names[i] = require.alias(names[i]);
        }
        //存储正在加载的模块标识
        var needMap = {};
        //存储加载模块数，用于异步加载最后回调触发用
        var needNum = 0;

        //根据参数里的模块名异步加载脚本
        function findNeed(depArr) {
            for(var i = 0, n = depArr.length; i < n; i++) {
                //
                // skip loading or loaded
                //
                var dep = depArr[i];

                var child = resMap[dep];
                if (child && 'deps' in child) {
                    findNeed(child.deps);
                }

                //如果要加载模块已经存在或者正在加载则跳过
                if (dep in factoryMap || dep in needMap) {
                    continue;
                }

                //needMap表明dep对应的模块正在加载
                needMap[dep] = true;
                //加载数自增
                needNum++;
                //加载脚本，如果加载完成了，被加载的脚本应该是define包装的函数执行，将执行updateNeed
                loadScript(dep, updateNeed, onerror);
            }
        }

        function updateNeed() {
            //当加载数为0，即加载全完成，
            if (0 == needNum--) {
                var args = [];
                //将加载模块依次作为参数传入回调中
                for(var i = 0, n = names.length; i < n; i++) {
                    args[i] = require(names[i]);
                }

                onload && onload.apply(global, args);
            }
        }

        findNeed(names);
        updateNeed();
    };
    //页面会针对async方法生成 该方法的script代码
    require.resourceMap = function(obj) {
        var k, col;

        // merge `res` & `pkg` fields
        col = obj.res;
        for(k in col) {
            if (col.hasOwnProperty(k)) {
                resMap[k] = col[k];
            }
        }

        col = obj.pkg;
        for(k in col) {
            if (col.hasOwnProperty(k)) {
                pkgMap[k] = col[k];
            }
        }
    };

    require.loadJs = function(url) {
        createScript(url);
    };

    require.loadCss = function(cfg) {
        if (cfg.content) {
            var sty = document.createElement('style');
            sty.type = 'text/css';

            if (sty.styleSheet) {       // IE
                sty.styleSheet.cssText = cfg.content;
            } else {
                sty.innerHTML = cfg.content;
            }
            head.appendChild(sty);
        }
        else if (cfg.url) {
            var link = document.createElement('link');
            link.href = cfg.url;
            link.rel = 'stylesheet';
            link.type = 'text/css';
            head.appendChild(link);
        }
    };

    //这个应该是为规范化模块命名做处理，不过这里貌似直接返回了
    require.alias = function(id) {return id};

    require.timeout = 5000;

})(this);

{%endhighlight%}


整篇代码注释下来，总结一下就是：

###核心：
1. __define__ ： 定义模块，将模块执行体缓存起来
2. __require__ ： 同步加载模块，返回模块执行体里的对象，页面渲染时提前将需要require的模板脚本都引入
3. __require.async__ ： 异步加载模块，即需要用到具体某一个模块时，才去引入模块脚本
这里不管是同步还是异步加载，只要都用的是id式引用，

####具体讲：
    同步，因为模块的define已经执行了 ，所以按id就能获取到模块对象，
    异步，需要页面渲染时调用`resourceMap`方法，参数为脚本的资源依赖表，用于异步加载时找准真正的脚本资源确保正常加载

> 反观在开发的业务项目中，极少甚至都没在用`require.async`，感觉用着`mod.js`也只用了它源码的三分之一的样子。