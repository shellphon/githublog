---
layout: post
title:  学习vuex之写一个todo
category: Hello Code
keywords: vuejs2, vuex, todomvc, vue-demo
description: 
---

2017年的第一篇博客诞生了，虽然又是一个demo，最近学习了下vuex，试着实现一下todo功能。

首先过一遍[vuex的文档](https://vuex.vuejs.org/zh-cn/getting-started.html)

可能看第一遍还是有点懵，一边写代码一边领悟效果更好。

vuex的主要几个概念：state、mutations、actions、getters、modules

另外vuex封装了几个辅助函数主要用于各个业务子组件的方便调用 mapXXX系列 

而那几个概念，都封在store对象里，而store则注入到Vue只中。

vue页面用到的数据绑定的数据，可以间接的利用store的state而不再是用自己声明的data对象了，这样达到对数据的一个统一。

比如，我们在state里定义了数据todos来存储所有待办事项内容。

那么我们在组件里就可以透过`$store.state.todos`来访问到数据todos，如果仅仅是要对todos做一些过滤数据处理获取特定数据（如未完成事项），可以在store里定义getters方法来返回todos的处理数据，通过`$store.getters.xxx`来调用。

涉及到需要调整state数据的内容，利用mutations和actions来处理，mutations类似事件，通过store.commit('type')来提交type的mutations，此时mutations就会回调 名为type的mutations，执行逻辑内对state进行数据操作，mutations是同步的。

所以如果涉及异步接口，比如需要先上传数据到后台，由后台提示成功后才能做处理时就不能直接操作mutations了，定义actions，commit的操作交由actions内实现的异步回调来，组件通过store `this.$store.dispatch('fetchTodos')`来分发actions。

![image](http://dont27.qiniudn.com/vuex.png)
<a href="http://dont27.qiniudn.com/vuex.png" target="_blank">查看原图</a>

todo我分了三个子组件 AddTodo\TodoItem\TodoList（一个新增表单、一个事项组件、一个事项列表）

todo主要以本地存储为主，所以用localstorage来存储数据即可。

以下为store的主要内容： 包含localstorage的操作、以及store定义

{%highlight javascript%}
import Vue from 'vue';
import Vuex from 'vuex';
import VueResource from 'vue-resource';

Vue.use(Vuex);
Vue.use(VueResource);
//定义一个id自增变量存储，用于新增数据时保证id唯一
let idIndex = 0;
//定义一个物理数据对象，相当于后台数据了，负责物理数据的存储和修改处理等
const gtoDos = (function(){
  var todos = [];
  var obj = function(){
    this.init();
    return this;
  };
  obj.prototype = {
    init(){
            //初始化时读出存储值
      var stores = window.localStorage.getItem('vtd-todos');
      if(stores){
        todos = JSON.parse(stores);
      }
    },
    getTodos() {
      return todos;
    },
    //新增数据
    addTodo(todo) {
      todos.push(todo);
      this.refreshTodos();
    },
    //删除数据
    deleteTodo(id) {
      todos = todos.filter(e=>{
        if(e.id==id){
          return false;
        }
        return true;
      });
      this.refreshTodos();
    },
    //切换具体事项
    toggleTodo(id) {
      todos = todos.map(e=>{
        if(e.id==id){
          e.done = !e.done;
        }
        return e;
      });
      this.refreshTodos();
    },
    //改动事项
    editTodo(item) {
      todos = todos.map(e=>{
        if(e.id==item.id){
          e = item;
        }
        return e;
      });
      this.refreshTodos();
    },
    //更新本地存储
    refreshTodos() {
      window.localStorage.setItem('vtd-todos', JSON.stringify(todos));
    }
  };
  return new obj();
})();
export default new Vuex.Store({
  state: {
    todos:[
    
    ]
  },
  mutations: {
      //获取列表数据，做了一下排序处理
    getTodos (state, list){
      var list = list.sort((a,b)=>a.id<b.id);
      idIndex = list.length && list[0].id || 0;
      state.todos = list.slice(0);
    },
    //新增显示数据
    addTodo (state, one){
      state.todos.unshift(one);
    },
    //编辑显示数据
    editTodo (state, one){
      state.todos = state.todos.map(e=>{
        if(e.id==one.id){
          e = one;
        }
        return e;
      })
    },
    toggleTodo (state, item){
      
    },
    //删除显示数据
    deleteTodo (state, item){
      state.todos = state.todos.filter(e=>{
        if(e.id==item.id){
          return false;
        }
        return true;
      })
    }
  },
  getters:{
      //获取显示数据中的已完成部分
    doneTodos: state=>{
      return state.todos.filter(todo => todo.done)
    },
    //获取未完成部分
    undoneTodos: state=>{
      return state.todos.filter(todo => !todo.done)
    }
  },

  actions:{
    /* 
    //异步操作
    fetchTodos ({commit}){

      Vue.http.get('/api/todos').then((response) => {
            // success callback
            //console.log('success');
        commit('getTodos',response.body.result.data);
            
          }, (response) => {
            console.log('error');
          });
    },
    newTodo ({commit}, todo){
      Vue.http.post('/api/addtodo', todo).then((response) => {
            // success callback
            //console.log('success');
        commit('addTodo', todo);
            
          }, (response) => {
            console.log('error');
          });
    },
    toggleTodo ({commit}, todo){
      Vue.http.post('/api/done', todo).then((response) => {
            // success callback
            //console.log('success');
        commit('toggleTodo', todo);
            
          }, (response) => {
            console.log('error');
          });
    },
    deleteTodo  ({commit}, todo){
      Vue.http.post('/api/delete', todo).then((response) => {
            // success callback
            //console.log('success');
        commit('deleteTodo', todo);
            
          }, (response) => {
            console.log('error');
          });
    }*/


    fetchTodos ({commit}){
       const res = gtoDos.getTodos();
       commit('getTodos',res);
    },
    newTodo ({commit}, todo){
      /*return new Promise((s,j)=>{
        j();
      })*/
      idIndex++;
      todo.id = idIndex;
       gtoDos.addTodo(todo);
        commit('addTodo', todo);
    },
    toggleTodo ({commit}, todo){
      gtoDos.toggleTodo(todo.id);
        commit('toggleTodo', todo);
    },
    deleteTodo  ({commit}, todo){
      gtoDos.deleteTodo(todo.id);
        commit('deleteTodo', todo);
    },
    editTodo ({commit}, todo){
      gtoDos.editTodo(todo);
      commit('editTodo', todo);
    }
  }
})
{%endhighlight%}

在main.js里注入store到根组件即可使用store

{%highlight javascript%}
import Vue from 'vue'
import App from './App'
import store from './store/index'

new Vue({
  el: '#app',
  template: '<App/>',
  store,
  components: { App }
})
{%endhighlight%}

### 新增表单

新增表单，相对简单，无需返回state数据，在data定义input来做双向绑定处理，提交数据时直接用input来构造新数据并分发actions
{%highlight javascript%}
<template>
  <div class="add-to-do">
    <h1><i class="glyphicon glyphicon-time"></i> To Do </h1>
    <form v-on:submit.prevent="onSubmit" role="form" class="form-horizontal" >
      <div class="form-group">
        <div class="col-sm-10">
          <input type="text" class="form-control" v-model="input" placeholder="输入事项~">
        </div>
          <button type="submit" class="btn btn-info col-sm-2">提交</button>
      </div>
    </form>
  </div>
</template>

<script>

import { mapActions } from 'vuex'

export default {
  name: 'AddToDo',
  data: function(){
    return {
      input:''
    }
  },
  created:function(){
    
  },
  methods:{
    onSubmit:function(){
      const todo = {
        done : false,
        desc : '',
        time : (new Date())
      };
      if(this.input==''){
        alert('不能为空');
        return;
      }
      todo.desc = this.input;
      //this.input = '';
      //通过dispatch分发actions，actions来处理数据，actions可以返回promise，然后由业务逻辑这边做相应处理
      this.$store.dispatch('newTodo', todo).then(()=>{
        this.input = '';
      }, ()=>{
        alert('出错');
      });

    }
  }
}
</script>
{%endhighlight%}

由于数据绑定的缘故 ，我们在列表组件那做好state的引用，当state发生变化时，页面显示自然也跟着变化。

### 具体事项

事项是列表的细化单位，一般具备显示跟删除功能，但todo还包含设置完成和修改事项的功能，所以实现的内容不会比新增数据简单。

这里还涉及到双击事项启动编辑功能以及自动聚焦的功能。

{%highlight javascript%}
<template>
  <li class="todo-item" :class='{editing: editable}'>
    <div class="view">
      <input type="checkbox" class="cb" :checked="item.done" @change="toggleTodo(item)">
      <label v-on:dblclick="toEdit()">{{item.desc}}</label>
      <a class="delete" @click="deleteItem">×</a>
    </div>
    <div class="col-sm-10 edit-input">
      <input type="text" class="form-control" v-auto-focus="editable" :value="item.desc"
      @keyup.enter="doneEdit"
      @keyup.esc="cancelEdit"
      @blur="doneEdit">
    </div>
  </li>
</template>

<script>
import Vue from 'vue';
//自定义指令，读取变量值来做自动聚焦处理
Vue.directive('auto-focus', function(el, binding){
  //console.log(binding.value);
  if(binding.value){
    el.focus();
  }
});
export default {
  name: 'TodoItem',
  //读取父组件传入的item
  props: ['item'],
  data: function(){
    return {
      input:'',
      //标识是否进入编辑
      editable:false
    }
  },
  created:function(){
    
  },
  methods:{
    doneEdit (e) {
      const value = e.target.value.trim();
      const { item } = this;
      if (!value) {
        this.deleteItem();
      } else if (this.editable) {
        item.desc = value;
        //分发编辑处理
        this.$store.dispatch('editTodo', item);
        this.editable = false
      }
    },
    cancelEdit (e) {
      e.target.value = this.item.desc
      this.editable = false
    },
    toEdit(){
      this.editable = true;
    },
    deleteItem (){
      const todo = this.item;
     //分发删除操作
      this.$store.dispatch('deleteTodo', todo);

    },
    toggleTodo (){
      const todo = this.item;
     /*console.log('组件点击',todo.done);*/
     //分发切换事项状态操作
      this.$store.dispatch('toggleTodo', todo);
    }
  }
}
</script>
{%endhighlight%}

### 列表组件

列表的功能，相对较少，处理传递子组件数据外，多了个切换显示事项功能。

显示完成和未完成的事项，可调用store的getters来实现，不需要发动到数据处理。

{%highlight javascript%}
<template>
  <div class="to-do-list">
    <ul class="todo-types">
      <li v-for="(obj, key) in filters" class="btn btn-default"
       :class="{'btn-success': key==visiableType}"
        role="button" @click="visiableType=key">{{obj.desc}}
        </li>
    </ul>
    <p v-show="filterTodos.length==0" style="text-align: center;">暂无对应信息</p>
    <ul class="todo-list">
      <TodoItem v-for='todo in filterTodos' :item="todo"></TodoItem>
    </ul>
  </div>
</template>

<script>
import TodoItem from './TodoItem'
import {mapGetters} from 'vuex'

const filters = {
  'all': { 
    type:'all',
    desc:'所有'  
  },
  'done':{
    type:'done',
    desc:'已完成'
  },
  'undone':{
    type:'undone',
    desc:'待完成'
  }
};

export default {
  name: 'TodoList',
  data:function(){
    return {
      visiableType:'all',
      filters:filters
    }
  },
  created:function(){
    this.$store.dispatch('fetchTodos');
  },
  components: {TodoItem},
  computed:{
    filterTodos (){
      return this[this.filters[this.visiableType]['type']];
    },
    all (){
      return this.$store.state.todos;
    },
    ...mapGetters({
      done: 'doneTodos',
      undone:'undoneTodos'
    })
  }
}
</script>
{%endhighlight%}

### 总结： 
  
  对vuex有了进一步的理解后，很快掌握其开发关键点，而且起初我实现的是异步接口与后台的对接实现，后来改成本地存储，结果发现，只需要修改store的actions实现即可，分工明确，相当不错，期间也补充了自己对vue一些认识的不足，比如computed是属性而不是方法等理解，自定义指令的使用。

源码地址： [https://github.com/shellphon/demo-codes/tree/master/mvm/vue-to-do](https://github.com/shellphon/demo-codes/tree/master/mvm/vue-to-do)
